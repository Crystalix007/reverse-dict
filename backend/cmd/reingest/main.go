package main

import (
	"context"
	"fmt"
	"log/slog"
	"net/url"
	"os"
	"slices"
	"time"

	"github.com/Crystalix007/reverse-dict/backend"
	"github.com/openai/openai-go/v2"
	"golang.org/x/time/rate"
)

func main() {
	ctx := context.Background()

	if err := reingest(ctx); err != nil {
		slog.ErrorContext(ctx, "reingesting words", slog.Any("error", err))
		os.Exit(1)
	}
}

func reingest(ctx context.Context) error {
	sqlite, err := backend.NewSQLiteVec(
		ctx,
		"words.db",
	)
	if err != nil {
		return fmt.Errorf("creating SQLiteVec: %w", err)
	}

	swama, err := backend.NewSwamaAPI(
		url.URL{
			Scheme: "http",
			Host:   "127.0.0.1:28100",
		},
	)
	if err != nil {
		return fmt.Errorf("creating SwamaAPI: %w", err)
	}

	embedders := backend.Embedders{
		backend.ModelQwen3Embedding8B4B_DWQ:    backend.NewSwamaEmbedder(swama),
		backend.ModelOpenAITextEmbedding3Large: backend.NewOpenAIEmbedder(openai.EmbeddingModelTextEmbedding3Large),
	}

	rateLimiter := rate.NewLimiter(rate.Every(500*time.Millisecond), 1)

	for word, err := range sqlite.GetWords(ctx) {
		if err := rateLimiter.Wait(ctx); err != nil {
			return err
		}

		slog.InfoContext(
			ctx,
			"reingesting definition",
			slog.String("word", word.Word.Word),
		)

		if err != nil {
			return fmt.Errorf("getting definitions: %w", err)
		}

		wordFeatures, err := sqlite.GetWordFeatures(ctx, word.ID)
		if err != nil {
			return fmt.Errorf("getting word features: %w", err)
		}

		// If we don't have any autogenerated features, generate some.
		if !slices.ContainsFunc(wordFeatures, func(f backend.Feature) bool {
			return f.Autogenerated
		}) {
			generatedDefs, err := swama.RephraseDefinition(ctx, word.Word)
			if err != nil {
				slog.ErrorContext(
					ctx,
					"rephrasing definition failed",
					slog.String("word", word.Word.Word),
					slog.Any("error", err),
				)

				continue
			}

			for _, generatedDef := range generatedDefs {
				wordFeatures = append(wordFeatures, backend.Feature{
					Embeddings:    map[backend.Model]backend.Embedding{},
					Phrase:        generatedDef,
					Autogenerated: true,
				})
			}
		}

		// Missing embeddings encodes all the (model, feature) pairs that are
		// missing embeddings.
		missingEmbeddings := make(map[backend.Model][]*backend.Feature)

		for _, model := range backend.Models {
			var features []*backend.Feature

			for i := range wordFeatures {
				if _, ok := wordFeatures[i].Embeddings[model]; !ok {
					features = append(features, &wordFeatures[i])
				}
			}

			// Only add models with missing features.
			if len(features) > 0 {
				missingEmbeddings[model] = features
			}
		}

		for model, features := range missingEmbeddings {
			featureStrings := make([]string, len(features))

			for i, feature := range features {
				featureStrings[i] = feature.Phrase
			}

			embedder, ok := embedders[model]
			if !ok {
				slog.ErrorContext(
					ctx,
					"missing embedder",
					slog.String("model", model.String()),
				)
				continue
			}

			embeddings, err := embedder.Embed(ctx, featureStrings...)
			if err != nil {
				slog.ErrorContext(
					ctx,
					"embedding definitions failed",
					slog.String("word", word.Word.Word),
					slog.String("model", model.String()),
					slog.Any("error", err),
				)
			}

			for i, embedding := range embeddings {
				features[i].Embeddings[model] = embedding
			}
		}

		if err := sqlite.AddFeatures(ctx, word.ID, wordFeatures); err != nil {
			return fmt.Errorf("adding word: %w", err)
		}
	}

	return nil
}
